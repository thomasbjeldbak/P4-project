//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.12.0
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from C:\Users\chris\OneDrive\Dokumenter\GitHub\P4-project\CobraCompiler\CobraCompiler\ExprParser.txt by ANTLR 4.12.0

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

using System;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.12.0")]
[System.CLSCompliant(false)]
public partial class ExprParser : Parser {
	protected static DFA[] decisionToDFA;
	protected static PredictionContextCache sharedContextCache = new PredictionContextCache();
	public const int
		OR=1, AND=2, EQUAL=3, NOT=4, GREAT=5, LESS=6, GREATEQL=7, LESSEQL=8, ASSIGN=9, 
		COMMA=10, SEMI=11, COLON=12, LPAREN=13, RPAREN=14, LCURLY=15, RCURLY=16, 
		TRUE=17, FALSE=18, ADD=19, SUB=20, MUL=21, DIV=22, BOOL=23, TEXT=24, NUM=25, 
		DECIMAL=26, NOTHING=27, LIST=28, QUOTE=29, IF=30, ELSE=31, REPEAT=32, 
		TIMES=33, WHILE=34, FOREACH=35, IN=36, FUNCTION=37, RETURN=38, CALL=39, 
		COMMENT=40, PRINT=41, SCAN=42, LISTADD=43, LISTIDXOF=44, LISTDEL=45, LISTVALOF=46, 
		COMM=47, STR=48, DEC=49, INT=50, ID=51, WS=52;
	public const int
		RULE_program = 0, RULE_cmds = 1, RULE_cmd = 2, RULE_dcl = 3, RULE_ass = 4, 
		RULE_stmt = 5, RULE_expr = 6, RULE_oprOr = 7, RULE_logicOr = 8, RULE_oprAnd = 9, 
		RULE_logicAnd = 10, RULE_oprEql = 11, RULE_equal = 12, RULE_oprBool = 13, 
		RULE_bool = 14, RULE_oprExpr = 15, RULE_term = 16, RULE_oprTerm = 17, 
		RULE_factor = 18, RULE_block = 19, RULE_commentStmt = 20, RULE_ctrlStrct = 21, 
		RULE_ifStmt = 22, RULE_elseIfStmt = 23, RULE_else = 24, RULE_loop = 25, 
		RULE_loops = 26, RULE_loopStmt = 27, RULE_whileStmt = 28, RULE_foreachStmt = 29, 
		RULE_listStmt = 30, RULE_listOpr = 31, RULE_listOprExpr = 32, RULE_funcCall = 33, 
		RULE_funcDef = 34, RULE_funcReturn = 35, RULE_funcReturnType = 36, RULE_paramList = 37, 
		RULE_paramTail = 38, RULE_param = 39, RULE_argList = 40, RULE_argTail = 41, 
		RULE_boolean = 42, RULE_type = 43;
	public static readonly string[] ruleNames = {
		"program", "cmds", "cmd", "dcl", "ass", "stmt", "expr", "oprOr", "logicOr", 
		"oprAnd", "logicAnd", "oprEql", "equal", "oprBool", "bool", "oprExpr", 
		"term", "oprTerm", "factor", "block", "commentStmt", "ctrlStrct", "ifStmt", 
		"elseIfStmt", "else", "loop", "loops", "loopStmt", "whileStmt", "foreachStmt", 
		"listStmt", "listOpr", "listOprExpr", "funcCall", "funcDef", "funcReturn", 
		"funcReturnType", "paramList", "paramTail", "param", "argList", "argTail", 
		"boolean", "type"
	};

	private static readonly string[] _LiteralNames = {
		null, "'or'", "'and'", "'is'", "'is not'", "'>'", "'<'", "'>='", "'<='", 
		"'='", "','", "';'", "':'", "'('", "')'", "'{'", "'}'", "'true'", "'false'", 
		"'+'", "'-'", "'*'", "'/'", "'boolean'", "'text'", "'number'", "'decimal'", 
		"'nothing'", "'list'", "'\"'", "'if'", "'else'", "'repeat'", "'times'", 
		"'while'", "'for each'", "'in'", "'function'", "'return'", "'call'", "'comment:'", 
		"'output'", "'input'", "'Add'", "'IndexOf'", "'Delete'", "'ValueOf'"
	};
	private static readonly string[] _SymbolicNames = {
		null, "OR", "AND", "EQUAL", "NOT", "GREAT", "LESS", "GREATEQL", "LESSEQL", 
		"ASSIGN", "COMMA", "SEMI", "COLON", "LPAREN", "RPAREN", "LCURLY", "RCURLY", 
		"TRUE", "FALSE", "ADD", "SUB", "MUL", "DIV", "BOOL", "TEXT", "NUM", "DECIMAL", 
		"NOTHING", "LIST", "QUOTE", "IF", "ELSE", "REPEAT", "TIMES", "WHILE", 
		"FOREACH", "IN", "FUNCTION", "RETURN", "CALL", "COMMENT", "PRINT", "SCAN", 
		"LISTADD", "LISTIDXOF", "LISTDEL", "LISTVALOF", "COMM", "STR", "DEC", 
		"INT", "ID", "WS"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "ExprParser.txt"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override int[] SerializedAtn { get { return _serializedATN; } }

	static ExprParser() {
		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
	}

		public ExprParser(ITokenStream input) : this(input, Console.Out, Console.Error) { }

		public ExprParser(ITokenStream input, TextWriter output, TextWriter errorOutput)
		: base(input, output, errorOutput)
	{
		Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
	}

	public partial class ProgramContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public CmdsContext cmds() {
			return GetRuleContext<CmdsContext>(0);
		}
		public ProgramContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_program; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.EnterProgram(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.ExitProgram(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExprParserVisitor<TResult> typedVisitor = visitor as IExprParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitProgram(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ProgramContext program() {
		ProgramContext _localctx = new ProgramContext(Context, State);
		EnterRule(_localctx, 0, RULE_program);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 88;
			cmds();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CmdsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public CmdContext cmd() {
			return GetRuleContext<CmdContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CmdsContext cmds() {
			return GetRuleContext<CmdsContext>(0);
		}
		public CmdsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cmds; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.EnterCmds(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.ExitCmds(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExprParserVisitor<TResult> typedVisitor = visitor as IExprParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCmds(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CmdsContext cmds() {
		CmdsContext _localctx = new CmdsContext(Context, State);
		EnterRule(_localctx, 2, RULE_cmds);
		try {
			State = 94;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case BOOL:
			case TEXT:
			case NUM:
			case DECIMAL:
			case LIST:
			case IF:
			case REPEAT:
			case FUNCTION:
			case RETURN:
			case CALL:
			case COMM:
			case ID:
				EnterOuterAlt(_localctx, 1);
				{
				State = 90;
				cmd();
				State = 91;
				cmds();
				}
				break;
			case Eof:
			case RCURLY:
				EnterOuterAlt(_localctx, 2);
				{
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CmdContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public StmtContext stmt() {
			return GetRuleContext<StmtContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DclContext dcl() {
			return GetRuleContext<DclContext>(0);
		}
		public CmdContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cmd; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.EnterCmd(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.ExitCmd(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExprParserVisitor<TResult> typedVisitor = visitor as IExprParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCmd(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CmdContext cmd() {
		CmdContext _localctx = new CmdContext(Context, State);
		EnterRule(_localctx, 4, RULE_cmd);
		try {
			State = 98;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case IF:
			case REPEAT:
			case FUNCTION:
			case RETURN:
			case CALL:
			case COMM:
			case ID:
				EnterOuterAlt(_localctx, 1);
				{
				State = 96;
				stmt();
				}
				break;
			case BOOL:
			case TEXT:
			case NUM:
			case DECIMAL:
			case LIST:
				EnterOuterAlt(_localctx, 2);
				{
				State = 97;
				dcl();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DclContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ID() { return GetToken(ExprParser.ID, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public AssContext ass() {
			return GetRuleContext<AssContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMI() { return GetToken(ExprParser.SEMI, 0); }
		public DclContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dcl; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.EnterDcl(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.ExitDcl(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExprParserVisitor<TResult> typedVisitor = visitor as IExprParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDcl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DclContext dcl() {
		DclContext _localctx = new DclContext(Context, State);
		EnterRule(_localctx, 6, RULE_dcl);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 100;
			type();
			State = 101;
			Match(ID);
			State = 102;
			ass();
			State = 103;
			Match(SEMI);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AssContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ASSIGN() { return GetToken(ExprParser.ASSIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		public AssContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ass; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.EnterAss(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.ExitAss(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExprParserVisitor<TResult> typedVisitor = visitor as IExprParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAss(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AssContext ass() {
		AssContext _localctx = new AssContext(Context, State);
		EnterRule(_localctx, 8, RULE_ass);
		try {
			State = 108;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ASSIGN:
				EnterOuterAlt(_localctx, 1);
				{
				State = 105;
				Match(ASSIGN);
				State = 106;
				expr();
				}
				break;
			case SEMI:
				EnterOuterAlt(_localctx, 2);
				{
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StmtContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ID() { return GetToken(ExprParser.ID, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ASSIGN() { return GetToken(ExprParser.ASSIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMI() { return GetToken(ExprParser.SEMI, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CtrlStrctContext ctrlStrct() {
			return GetRuleContext<CtrlStrctContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ListStmtContext listStmt() {
			return GetRuleContext<ListStmtContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FuncDefContext funcDef() {
			return GetRuleContext<FuncDefContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FuncCallContext funcCall() {
			return GetRuleContext<FuncCallContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CommentStmtContext commentStmt() {
			return GetRuleContext<CommentStmtContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RETURN() { return GetToken(ExprParser.RETURN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		public StmtContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_stmt; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.EnterStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.ExitStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExprParserVisitor<TResult> typedVisitor = visitor as IExprParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStmt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StmtContext stmt() {
		StmtContext _localctx = new StmtContext(Context, State);
		EnterRule(_localctx, 10, RULE_stmt);
		try {
			State = 130;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,3,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 110;
				Match(ID);
				State = 111;
				Match(ASSIGN);
				State = 112;
				expr();
				State = 113;
				Match(SEMI);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 115;
				ctrlStrct();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 116;
				listStmt();
				State = 117;
				Match(SEMI);
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 119;
				funcDef();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 120;
				funcCall();
				State = 121;
				Match(SEMI);
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 123;
				commentStmt();
				State = 124;
				Match(SEMI);
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 126;
				Match(RETURN);
				State = 127;
				type();
				State = 128;
				Match(SEMI);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExprContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public LogicOrContext logicOr() {
			return GetRuleContext<LogicOrContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OprOrContext oprOr() {
			return GetRuleContext<OprOrContext>(0);
		}
		public ExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expr; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.EnterExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.ExitExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExprParserVisitor<TResult> typedVisitor = visitor as IExprParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExprContext expr() {
		ExprContext _localctx = new ExprContext(Context, State);
		EnterRule(_localctx, 12, RULE_expr);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 132;
			logicOr();
			State = 133;
			oprOr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OprOrContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OR() { return GetToken(ExprParser.OR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LogicOrContext logicOr() {
			return GetRuleContext<LogicOrContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OprOrContext oprOr() {
			return GetRuleContext<OprOrContext>(0);
		}
		public OprOrContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_oprOr; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.EnterOprOr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.ExitOprOr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExprParserVisitor<TResult> typedVisitor = visitor as IExprParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOprOr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OprOrContext oprOr() {
		OprOrContext _localctx = new OprOrContext(Context, State);
		EnterRule(_localctx, 14, RULE_oprOr);
		try {
			State = 140;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case OR:
				EnterOuterAlt(_localctx, 1);
				{
				State = 135;
				Match(OR);
				State = 136;
				logicOr();
				State = 137;
				oprOr();
				}
				break;
			case COMMA:
			case SEMI:
			case RPAREN:
				EnterOuterAlt(_localctx, 2);
				{
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LogicOrContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public LogicAndContext logicAnd() {
			return GetRuleContext<LogicAndContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OprAndContext oprAnd() {
			return GetRuleContext<OprAndContext>(0);
		}
		public LogicOrContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_logicOr; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.EnterLogicOr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.ExitLogicOr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExprParserVisitor<TResult> typedVisitor = visitor as IExprParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLogicOr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LogicOrContext logicOr() {
		LogicOrContext _localctx = new LogicOrContext(Context, State);
		EnterRule(_localctx, 16, RULE_logicOr);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 142;
			logicAnd();
			State = 143;
			oprAnd();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OprAndContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AND() { return GetToken(ExprParser.AND, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LogicAndContext logicAnd() {
			return GetRuleContext<LogicAndContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OprAndContext oprAnd() {
			return GetRuleContext<OprAndContext>(0);
		}
		public OprAndContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_oprAnd; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.EnterOprAnd(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.ExitOprAnd(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExprParserVisitor<TResult> typedVisitor = visitor as IExprParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOprAnd(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OprAndContext oprAnd() {
		OprAndContext _localctx = new OprAndContext(Context, State);
		EnterRule(_localctx, 18, RULE_oprAnd);
		try {
			State = 150;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case AND:
				EnterOuterAlt(_localctx, 1);
				{
				State = 145;
				Match(AND);
				State = 146;
				logicAnd();
				State = 147;
				oprAnd();
				}
				break;
			case OR:
			case COMMA:
			case SEMI:
			case RPAREN:
				EnterOuterAlt(_localctx, 2);
				{
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LogicAndContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public EqualContext equal() {
			return GetRuleContext<EqualContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OprEqlContext oprEql() {
			return GetRuleContext<OprEqlContext>(0);
		}
		public LogicAndContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_logicAnd; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.EnterLogicAnd(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.ExitLogicAnd(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExprParserVisitor<TResult> typedVisitor = visitor as IExprParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLogicAnd(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LogicAndContext logicAnd() {
		LogicAndContext _localctx = new LogicAndContext(Context, State);
		EnterRule(_localctx, 20, RULE_logicAnd);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 152;
			equal();
			State = 153;
			oprEql();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OprEqlContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EQUAL() { return GetToken(ExprParser.EQUAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public EqualContext equal() {
			return GetRuleContext<EqualContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OprEqlContext oprEql() {
			return GetRuleContext<OprEqlContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOT() { return GetToken(ExprParser.NOT, 0); }
		public OprEqlContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_oprEql; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.EnterOprEql(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.ExitOprEql(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExprParserVisitor<TResult> typedVisitor = visitor as IExprParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOprEql(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OprEqlContext oprEql() {
		OprEqlContext _localctx = new OprEqlContext(Context, State);
		EnterRule(_localctx, 22, RULE_oprEql);
		try {
			State = 164;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case EQUAL:
				EnterOuterAlt(_localctx, 1);
				{
				State = 155;
				Match(EQUAL);
				State = 156;
				equal();
				State = 157;
				oprEql();
				}
				break;
			case NOT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 159;
				Match(NOT);
				State = 160;
				equal();
				State = 161;
				oprEql();
				}
				break;
			case OR:
			case AND:
			case COMMA:
			case SEMI:
			case RPAREN:
				EnterOuterAlt(_localctx, 3);
				{
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EqualContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public BoolContext @bool() {
			return GetRuleContext<BoolContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OprBoolContext oprBool() {
			return GetRuleContext<OprBoolContext>(0);
		}
		public EqualContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_equal; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.EnterEqual(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.ExitEqual(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExprParserVisitor<TResult> typedVisitor = visitor as IExprParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEqual(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EqualContext equal() {
		EqualContext _localctx = new EqualContext(Context, State);
		EnterRule(_localctx, 24, RULE_equal);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 166;
			@bool();
			State = 167;
			oprBool();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OprBoolContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GREAT() { return GetToken(ExprParser.GREAT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BoolContext @bool() {
			return GetRuleContext<BoolContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OprBoolContext oprBool() {
			return GetRuleContext<OprBoolContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LESS() { return GetToken(ExprParser.LESS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GREATEQL() { return GetToken(ExprParser.GREATEQL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LESSEQL() { return GetToken(ExprParser.LESSEQL, 0); }
		public OprBoolContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_oprBool; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.EnterOprBool(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.ExitOprBool(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExprParserVisitor<TResult> typedVisitor = visitor as IExprParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOprBool(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OprBoolContext oprBool() {
		OprBoolContext _localctx = new OprBoolContext(Context, State);
		EnterRule(_localctx, 26, RULE_oprBool);
		try {
			State = 186;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case GREAT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 169;
				Match(GREAT);
				State = 170;
				@bool();
				State = 171;
				oprBool();
				}
				break;
			case LESS:
				EnterOuterAlt(_localctx, 2);
				{
				State = 173;
				Match(LESS);
				State = 174;
				@bool();
				State = 175;
				oprBool();
				}
				break;
			case GREATEQL:
				EnterOuterAlt(_localctx, 3);
				{
				State = 177;
				Match(GREATEQL);
				State = 178;
				@bool();
				State = 179;
				oprBool();
				}
				break;
			case LESSEQL:
				EnterOuterAlt(_localctx, 4);
				{
				State = 181;
				Match(LESSEQL);
				State = 182;
				@bool();
				State = 183;
				oprBool();
				}
				break;
			case OR:
			case AND:
			case EQUAL:
			case NOT:
			case COMMA:
			case SEMI:
			case RPAREN:
				EnterOuterAlt(_localctx, 5);
				{
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BoolContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TermContext term() {
			return GetRuleContext<TermContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OprExprContext oprExpr() {
			return GetRuleContext<OprExprContext>(0);
		}
		public BoolContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_bool; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.EnterBool(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.ExitBool(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExprParserVisitor<TResult> typedVisitor = visitor as IExprParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBool(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BoolContext @bool() {
		BoolContext _localctx = new BoolContext(Context, State);
		EnterRule(_localctx, 28, RULE_bool);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 188;
			term();
			State = 189;
			oprExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OprExprContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ADD() { return GetToken(ExprParser.ADD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TermContext term() {
			return GetRuleContext<TermContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OprExprContext oprExpr() {
			return GetRuleContext<OprExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SUB() { return GetToken(ExprParser.SUB, 0); }
		public OprExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_oprExpr; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.EnterOprExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.ExitOprExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExprParserVisitor<TResult> typedVisitor = visitor as IExprParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOprExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OprExprContext oprExpr() {
		OprExprContext _localctx = new OprExprContext(Context, State);
		EnterRule(_localctx, 30, RULE_oprExpr);
		try {
			State = 200;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ADD:
				EnterOuterAlt(_localctx, 1);
				{
				State = 191;
				Match(ADD);
				State = 192;
				term();
				State = 193;
				oprExpr();
				}
				break;
			case SUB:
				EnterOuterAlt(_localctx, 2);
				{
				State = 195;
				Match(SUB);
				State = 196;
				term();
				State = 197;
				oprExpr();
				}
				break;
			case OR:
			case AND:
			case EQUAL:
			case NOT:
			case GREAT:
			case LESS:
			case GREATEQL:
			case LESSEQL:
			case COMMA:
			case SEMI:
			case RPAREN:
				EnterOuterAlt(_localctx, 3);
				{
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TermContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FactorContext factor() {
			return GetRuleContext<FactorContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OprTermContext oprTerm() {
			return GetRuleContext<OprTermContext>(0);
		}
		public TermContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_term; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.EnterTerm(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.ExitTerm(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExprParserVisitor<TResult> typedVisitor = visitor as IExprParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTerm(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TermContext term() {
		TermContext _localctx = new TermContext(Context, State);
		EnterRule(_localctx, 32, RULE_term);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 202;
			factor();
			State = 203;
			oprTerm();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OprTermContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MUL() { return GetToken(ExprParser.MUL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FactorContext factor() {
			return GetRuleContext<FactorContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OprTermContext oprTerm() {
			return GetRuleContext<OprTermContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DIV() { return GetToken(ExprParser.DIV, 0); }
		public OprTermContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_oprTerm; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.EnterOprTerm(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.ExitOprTerm(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExprParserVisitor<TResult> typedVisitor = visitor as IExprParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOprTerm(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OprTermContext oprTerm() {
		OprTermContext _localctx = new OprTermContext(Context, State);
		EnterRule(_localctx, 34, RULE_oprTerm);
		try {
			State = 214;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case MUL:
				EnterOuterAlt(_localctx, 1);
				{
				State = 205;
				Match(MUL);
				State = 206;
				factor();
				State = 207;
				oprTerm();
				}
				break;
			case DIV:
				EnterOuterAlt(_localctx, 2);
				{
				State = 209;
				Match(DIV);
				State = 210;
				factor();
				State = 211;
				oprTerm();
				}
				break;
			case OR:
			case AND:
			case EQUAL:
			case NOT:
			case GREAT:
			case LESS:
			case GREATEQL:
			case LESSEQL:
			case COMMA:
			case SEMI:
			case RPAREN:
			case ADD:
			case SUB:
				EnterOuterAlt(_localctx, 3);
				{
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FactorContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(ExprParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(ExprParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FuncCallContext funcCall() {
			return GetRuleContext<FuncCallContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ListOprExprContext listOprExpr() {
			return GetRuleContext<ListOprExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INT() { return GetToken(ExprParser.INT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEC() { return GetToken(ExprParser.DEC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STR() { return GetToken(ExprParser.STR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ID() { return GetToken(ExprParser.ID, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BooleanContext boolean() {
			return GetRuleContext<BooleanContext>(0);
		}
		public FactorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_factor; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.EnterFactor(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.ExitFactor(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExprParserVisitor<TResult> typedVisitor = visitor as IExprParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFactor(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FactorContext factor() {
		FactorContext _localctx = new FactorContext(Context, State);
		EnterRule(_localctx, 36, RULE_factor);
		try {
			State = 227;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,10,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 216;
				Match(LPAREN);
				State = 217;
				expr();
				State = 218;
				Match(RPAREN);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 220;
				funcCall();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 221;
				listOprExpr();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 222;
				Match(INT);
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 223;
				Match(DEC);
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 224;
				Match(STR);
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 225;
				Match(ID);
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 226;
				boolean();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BlockContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LCURLY() { return GetToken(ExprParser.LCURLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CmdsContext cmds() {
			return GetRuleContext<CmdsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RCURLY() { return GetToken(ExprParser.RCURLY, 0); }
		public BlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_block; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.EnterBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.ExitBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExprParserVisitor<TResult> typedVisitor = visitor as IExprParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlock(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BlockContext block() {
		BlockContext _localctx = new BlockContext(Context, State);
		EnterRule(_localctx, 38, RULE_block);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 229;
			Match(LCURLY);
			State = 230;
			cmds();
			State = 231;
			Match(RCURLY);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CommentStmtContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMM() { return GetToken(ExprParser.COMM, 0); }
		public CommentStmtContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_commentStmt; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.EnterCommentStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.ExitCommentStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExprParserVisitor<TResult> typedVisitor = visitor as IExprParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCommentStmt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CommentStmtContext commentStmt() {
		CommentStmtContext _localctx = new CommentStmtContext(Context, State);
		EnterRule(_localctx, 40, RULE_commentStmt);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 233;
			Match(COMM);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CtrlStrctContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public IfStmtContext ifStmt() {
			return GetRuleContext<IfStmtContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LoopContext loop() {
			return GetRuleContext<LoopContext>(0);
		}
		public CtrlStrctContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ctrlStrct; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.EnterCtrlStrct(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.ExitCtrlStrct(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExprParserVisitor<TResult> typedVisitor = visitor as IExprParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCtrlStrct(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CtrlStrctContext ctrlStrct() {
		CtrlStrctContext _localctx = new CtrlStrctContext(Context, State);
		EnterRule(_localctx, 42, RULE_ctrlStrct);
		try {
			State = 237;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case IF:
				EnterOuterAlt(_localctx, 1);
				{
				State = 235;
				ifStmt();
				}
				break;
			case REPEAT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 236;
				loop();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IfStmtContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IF() { return GetToken(ExprParser.IF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(ExprParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(ExprParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockContext block() {
			return GetRuleContext<BlockContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ElseIfStmtContext elseIfStmt() {
			return GetRuleContext<ElseIfStmtContext>(0);
		}
		public IfStmtContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ifStmt; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.EnterIfStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.ExitIfStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExprParserVisitor<TResult> typedVisitor = visitor as IExprParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIfStmt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IfStmtContext ifStmt() {
		IfStmtContext _localctx = new IfStmtContext(Context, State);
		EnterRule(_localctx, 44, RULE_ifStmt);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 239;
			Match(IF);
			State = 240;
			Match(LPAREN);
			State = 241;
			expr();
			State = 242;
			Match(RPAREN);
			State = 243;
			block();
			State = 244;
			elseIfStmt();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ElseIfStmtContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ELSE() { return GetToken(ExprParser.ELSE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IF() { return GetToken(ExprParser.IF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(ExprParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(ExprParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockContext block() {
			return GetRuleContext<BlockContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ElseIfStmtContext elseIfStmt() {
			return GetRuleContext<ElseIfStmtContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ElseContext @else() {
			return GetRuleContext<ElseContext>(0);
		}
		public ElseIfStmtContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_elseIfStmt; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.EnterElseIfStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.ExitElseIfStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExprParserVisitor<TResult> typedVisitor = visitor as IExprParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElseIfStmt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ElseIfStmtContext elseIfStmt() {
		ElseIfStmtContext _localctx = new ElseIfStmtContext(Context, State);
		EnterRule(_localctx, 46, RULE_elseIfStmt);
		try {
			State = 256;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,12,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 246;
				Match(ELSE);
				State = 247;
				Match(IF);
				State = 248;
				Match(LPAREN);
				State = 249;
				expr();
				State = 250;
				Match(RPAREN);
				State = 251;
				block();
				State = 252;
				elseIfStmt();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 254;
				@else();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ElseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ELSE() { return GetToken(ExprParser.ELSE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockContext block() {
			return GetRuleContext<BlockContext>(0);
		}
		public ElseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_else; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.EnterElse(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.ExitElse(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExprParserVisitor<TResult> typedVisitor = visitor as IExprParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElse(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ElseContext @else() {
		ElseContext _localctx = new ElseContext(Context, State);
		EnterRule(_localctx, 48, RULE_else);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 258;
			Match(ELSE);
			State = 259;
			block();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LoopContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REPEAT() { return GetToken(ExprParser.REPEAT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LoopsContext loops() {
			return GetRuleContext<LoopsContext>(0);
		}
		public LoopContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_loop; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.EnterLoop(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.ExitLoop(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExprParserVisitor<TResult> typedVisitor = visitor as IExprParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLoop(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LoopContext loop() {
		LoopContext _localctx = new LoopContext(Context, State);
		EnterRule(_localctx, 50, RULE_loop);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 261;
			Match(REPEAT);
			State = 262;
			loops();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LoopsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public LoopStmtContext loopStmt() {
			return GetRuleContext<LoopStmtContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public WhileStmtContext whileStmt() {
			return GetRuleContext<WhileStmtContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ForeachStmtContext foreachStmt() {
			return GetRuleContext<ForeachStmtContext>(0);
		}
		public LoopsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_loops; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.EnterLoops(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.ExitLoops(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExprParserVisitor<TResult> typedVisitor = visitor as IExprParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLoops(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LoopsContext loops() {
		LoopsContext _localctx = new LoopsContext(Context, State);
		EnterRule(_localctx, 52, RULE_loops);
		try {
			State = 267;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case LPAREN:
				EnterOuterAlt(_localctx, 1);
				{
				State = 264;
				loopStmt();
				}
				break;
			case WHILE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 265;
				whileStmt();
				}
				break;
			case FOREACH:
				EnterOuterAlt(_localctx, 3);
				{
				State = 266;
				foreachStmt();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LoopStmtContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(ExprParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(ExprParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TIMES() { return GetToken(ExprParser.TIMES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockContext block() {
			return GetRuleContext<BlockContext>(0);
		}
		public LoopStmtContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_loopStmt; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.EnterLoopStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.ExitLoopStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExprParserVisitor<TResult> typedVisitor = visitor as IExprParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLoopStmt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LoopStmtContext loopStmt() {
		LoopStmtContext _localctx = new LoopStmtContext(Context, State);
		EnterRule(_localctx, 54, RULE_loopStmt);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 269;
			Match(LPAREN);
			State = 270;
			expr();
			State = 271;
			Match(RPAREN);
			State = 272;
			Match(TIMES);
			State = 273;
			block();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WhileStmtContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WHILE() { return GetToken(ExprParser.WHILE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(ExprParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(ExprParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockContext block() {
			return GetRuleContext<BlockContext>(0);
		}
		public WhileStmtContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_whileStmt; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.EnterWhileStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.ExitWhileStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExprParserVisitor<TResult> typedVisitor = visitor as IExprParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWhileStmt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public WhileStmtContext whileStmt() {
		WhileStmtContext _localctx = new WhileStmtContext(Context, State);
		EnterRule(_localctx, 56, RULE_whileStmt);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 275;
			Match(WHILE);
			State = 276;
			Match(LPAREN);
			State = 277;
			expr();
			State = 278;
			Match(RPAREN);
			State = 279;
			block();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ForeachStmtContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FOREACH() { return GetToken(ExprParser.FOREACH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(ExprParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] ID() { return GetTokens(ExprParser.ID); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ID(int i) {
			return GetToken(ExprParser.ID, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IN() { return GetToken(ExprParser.IN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(ExprParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockContext block() {
			return GetRuleContext<BlockContext>(0);
		}
		public ForeachStmtContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_foreachStmt; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.EnterForeachStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.ExitForeachStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExprParserVisitor<TResult> typedVisitor = visitor as IExprParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitForeachStmt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ForeachStmtContext foreachStmt() {
		ForeachStmtContext _localctx = new ForeachStmtContext(Context, State);
		EnterRule(_localctx, 58, RULE_foreachStmt);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 281;
			Match(FOREACH);
			State = 282;
			Match(LPAREN);
			State = 283;
			type();
			State = 284;
			Match(ID);
			State = 285;
			Match(IN);
			State = 286;
			Match(ID);
			State = 287;
			Match(RPAREN);
			State = 288;
			block();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ListStmtContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ListOprContext listOpr() {
			return GetRuleContext<ListOprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ListOprExprContext listOprExpr() {
			return GetRuleContext<ListOprExprContext>(0);
		}
		public ListStmtContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_listStmt; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.EnterListStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.ExitListStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExprParserVisitor<TResult> typedVisitor = visitor as IExprParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitListStmt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ListStmtContext listStmt() {
		ListStmtContext _localctx = new ListStmtContext(Context, State);
		EnterRule(_localctx, 60, RULE_listStmt);
		try {
			State = 292;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,14,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 290;
				listOpr();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 291;
				listOprExpr();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ListOprContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ID() { return GetToken(ExprParser.ID, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLON() { return GetToken(ExprParser.COLON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LISTADD() { return GetToken(ExprParser.LISTADD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(ExprParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ArgListContext argList() {
			return GetRuleContext<ArgListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(ExprParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LISTDEL() { return GetToken(ExprParser.LISTDEL, 0); }
		public ListOprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_listOpr; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.EnterListOpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.ExitListOpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExprParserVisitor<TResult> typedVisitor = visitor as IExprParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitListOpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ListOprContext listOpr() {
		ListOprContext _localctx = new ListOprContext(Context, State);
		EnterRule(_localctx, 62, RULE_listOpr);
		try {
			State = 308;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,15,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 294;
				Match(ID);
				State = 295;
				Match(COLON);
				State = 296;
				Match(LISTADD);
				State = 297;
				Match(LPAREN);
				State = 298;
				argList();
				State = 299;
				Match(RPAREN);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 301;
				Match(ID);
				State = 302;
				Match(COLON);
				State = 303;
				Match(LISTDEL);
				State = 304;
				Match(LPAREN);
				State = 305;
				argList();
				State = 306;
				Match(RPAREN);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ListOprExprContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ID() { return GetToken(ExprParser.ID, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLON() { return GetToken(ExprParser.COLON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LISTIDXOF() { return GetToken(ExprParser.LISTIDXOF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(ExprParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ArgListContext argList() {
			return GetRuleContext<ArgListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(ExprParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LISTVALOF() { return GetToken(ExprParser.LISTVALOF, 0); }
		public ListOprExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_listOprExpr; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.EnterListOprExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.ExitListOprExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExprParserVisitor<TResult> typedVisitor = visitor as IExprParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitListOprExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ListOprExprContext listOprExpr() {
		ListOprExprContext _localctx = new ListOprExprContext(Context, State);
		EnterRule(_localctx, 64, RULE_listOprExpr);
		try {
			State = 324;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,16,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 310;
				Match(ID);
				State = 311;
				Match(COLON);
				State = 312;
				Match(LISTIDXOF);
				State = 313;
				Match(LPAREN);
				State = 314;
				argList();
				State = 315;
				Match(RPAREN);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 317;
				Match(ID);
				State = 318;
				Match(COLON);
				State = 319;
				Match(LISTVALOF);
				State = 320;
				Match(LPAREN);
				State = 321;
				argList();
				State = 322;
				Match(RPAREN);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FuncCallContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CALL() { return GetToken(ExprParser.CALL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ID() { return GetToken(ExprParser.ID, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(ExprParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ArgListContext argList() {
			return GetRuleContext<ArgListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(ExprParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PRINT() { return GetToken(ExprParser.PRINT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SCAN() { return GetToken(ExprParser.SCAN, 0); }
		public FuncCallContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_funcCall; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.EnterFuncCall(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.ExitFuncCall(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExprParserVisitor<TResult> typedVisitor = visitor as IExprParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFuncCall(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FuncCallContext funcCall() {
		FuncCallContext _localctx = new FuncCallContext(Context, State);
		EnterRule(_localctx, 66, RULE_funcCall);
		try {
			State = 345;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,17,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 326;
				Match(CALL);
				State = 327;
				Match(ID);
				State = 328;
				Match(LPAREN);
				State = 329;
				argList();
				State = 330;
				Match(RPAREN);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 332;
				Match(CALL);
				State = 333;
				Match(PRINT);
				State = 334;
				Match(LPAREN);
				State = 335;
				argList();
				State = 336;
				Match(RPAREN);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 338;
				Match(CALL);
				State = 339;
				type();
				State = 340;
				Match(SCAN);
				State = 341;
				Match(LPAREN);
				State = 342;
				argList();
				State = 343;
				Match(RPAREN);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FuncDefContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FUNCTION() { return GetToken(ExprParser.FUNCTION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ID() { return GetToken(ExprParser.ID, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(ExprParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ParamListContext paramList() {
			return GetRuleContext<ParamListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(ExprParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FuncReturnContext funcReturn() {
			return GetRuleContext<FuncReturnContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockContext block() {
			return GetRuleContext<BlockContext>(0);
		}
		public FuncDefContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_funcDef; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.EnterFuncDef(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.ExitFuncDef(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExprParserVisitor<TResult> typedVisitor = visitor as IExprParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFuncDef(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FuncDefContext funcDef() {
		FuncDefContext _localctx = new FuncDefContext(Context, State);
		EnterRule(_localctx, 68, RULE_funcDef);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 347;
			Match(FUNCTION);
			State = 348;
			Match(ID);
			State = 349;
			Match(LPAREN);
			State = 350;
			paramList();
			State = 351;
			Match(RPAREN);
			State = 352;
			funcReturn();
			State = 353;
			block();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FuncReturnContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RETURN() { return GetToken(ExprParser.RETURN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FuncReturnTypeContext funcReturnType() {
			return GetRuleContext<FuncReturnTypeContext>(0);
		}
		public FuncReturnContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_funcReturn; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.EnterFuncReturn(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.ExitFuncReturn(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExprParserVisitor<TResult> typedVisitor = visitor as IExprParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFuncReturn(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FuncReturnContext funcReturn() {
		FuncReturnContext _localctx = new FuncReturnContext(Context, State);
		EnterRule(_localctx, 70, RULE_funcReturn);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 355;
			Match(RETURN);
			State = 356;
			funcReturnType();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FuncReturnTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOTHING() { return GetToken(ExprParser.NOTHING, 0); }
		public FuncReturnTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_funcReturnType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.EnterFuncReturnType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.ExitFuncReturnType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExprParserVisitor<TResult> typedVisitor = visitor as IExprParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFuncReturnType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FuncReturnTypeContext funcReturnType() {
		FuncReturnTypeContext _localctx = new FuncReturnTypeContext(Context, State);
		EnterRule(_localctx, 72, RULE_funcReturnType);
		try {
			State = 360;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case BOOL:
			case TEXT:
			case NUM:
			case DECIMAL:
			case LIST:
				EnterOuterAlt(_localctx, 1);
				{
				State = 358;
				type();
				}
				break;
			case NOTHING:
				EnterOuterAlt(_localctx, 2);
				{
				State = 359;
				Match(NOTHING);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ParamListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ParamContext param() {
			return GetRuleContext<ParamContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ParamTailContext paramTail() {
			return GetRuleContext<ParamTailContext>(0);
		}
		public ParamListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_paramList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.EnterParamList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.ExitParamList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExprParserVisitor<TResult> typedVisitor = visitor as IExprParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParamList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ParamListContext paramList() {
		ParamListContext _localctx = new ParamListContext(Context, State);
		EnterRule(_localctx, 74, RULE_paramList);
		try {
			State = 366;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case BOOL:
			case TEXT:
			case NUM:
			case DECIMAL:
			case LIST:
				EnterOuterAlt(_localctx, 1);
				{
				State = 362;
				param();
				State = 363;
				paramTail();
				}
				break;
			case RPAREN:
				EnterOuterAlt(_localctx, 2);
				{
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ParamTailContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA() { return GetToken(ExprParser.COMMA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ParamContext param() {
			return GetRuleContext<ParamContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ParamTailContext paramTail() {
			return GetRuleContext<ParamTailContext>(0);
		}
		public ParamTailContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_paramTail; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.EnterParamTail(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.ExitParamTail(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExprParserVisitor<TResult> typedVisitor = visitor as IExprParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParamTail(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ParamTailContext paramTail() {
		ParamTailContext _localctx = new ParamTailContext(Context, State);
		EnterRule(_localctx, 76, RULE_paramTail);
		try {
			State = 373;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case COMMA:
				EnterOuterAlt(_localctx, 1);
				{
				State = 368;
				Match(COMMA);
				State = 369;
				param();
				State = 370;
				paramTail();
				}
				break;
			case RPAREN:
				EnterOuterAlt(_localctx, 2);
				{
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ParamContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ID() { return GetToken(ExprParser.ID, 0); }
		public ParamContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_param; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.EnterParam(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.ExitParam(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExprParserVisitor<TResult> typedVisitor = visitor as IExprParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParam(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ParamContext param() {
		ParamContext _localctx = new ParamContext(Context, State);
		EnterRule(_localctx, 78, RULE_param);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 375;
			type();
			State = 376;
			Match(ID);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArgListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ArgTailContext argTail() {
			return GetRuleContext<ArgTailContext>(0);
		}
		public ArgListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_argList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.EnterArgList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.ExitArgList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExprParserVisitor<TResult> typedVisitor = visitor as IExprParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArgList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ArgListContext argList() {
		ArgListContext _localctx = new ArgListContext(Context, State);
		EnterRule(_localctx, 80, RULE_argList);
		try {
			State = 382;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case LPAREN:
			case TRUE:
			case FALSE:
			case CALL:
			case STR:
			case DEC:
			case INT:
			case ID:
				EnterOuterAlt(_localctx, 1);
				{
				State = 378;
				expr();
				State = 379;
				argTail();
				}
				break;
			case RPAREN:
				EnterOuterAlt(_localctx, 2);
				{
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArgTailContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA() { return GetToken(ExprParser.COMMA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ArgTailContext argTail() {
			return GetRuleContext<ArgTailContext>(0);
		}
		public ArgTailContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_argTail; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.EnterArgTail(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.ExitArgTail(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExprParserVisitor<TResult> typedVisitor = visitor as IExprParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArgTail(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ArgTailContext argTail() {
		ArgTailContext _localctx = new ArgTailContext(Context, State);
		EnterRule(_localctx, 82, RULE_argTail);
		try {
			State = 389;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case COMMA:
				EnterOuterAlt(_localctx, 1);
				{
				State = 384;
				Match(COMMA);
				State = 385;
				expr();
				State = 386;
				argTail();
				}
				break;
			case RPAREN:
				EnterOuterAlt(_localctx, 2);
				{
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BooleanContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TRUE() { return GetToken(ExprParser.TRUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FALSE() { return GetToken(ExprParser.FALSE, 0); }
		public BooleanContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_boolean; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.EnterBoolean(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.ExitBoolean(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExprParserVisitor<TResult> typedVisitor = visitor as IExprParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBoolean(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BooleanContext boolean() {
		BooleanContext _localctx = new BooleanContext(Context, State);
		EnterRule(_localctx, 84, RULE_boolean);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 391;
			_la = TokenStream.LA(1);
			if ( !(_la==TRUE || _la==FALSE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BOOL() { return GetToken(ExprParser.BOOL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TEXT() { return GetToken(ExprParser.TEXT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NUM() { return GetToken(ExprParser.NUM, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LIST() { return GetToken(ExprParser.LIST, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(ExprParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(ExprParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DECIMAL() { return GetToken(ExprParser.DECIMAL, 0); }
		public TypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.EnterType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IExprParserListener typedListener = listener as IExprParserListener;
			if (typedListener != null) typedListener.ExitType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExprParserVisitor<TResult> typedVisitor = visitor as IExprParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeContext type() {
		TypeContext _localctx = new TypeContext(Context, State);
		EnterRule(_localctx, 86, RULE_type);
		try {
			State = 402;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case BOOL:
				EnterOuterAlt(_localctx, 1);
				{
				State = 393;
				Match(BOOL);
				}
				break;
			case TEXT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 394;
				Match(TEXT);
				}
				break;
			case NUM:
				EnterOuterAlt(_localctx, 3);
				{
				State = 395;
				Match(NUM);
				}
				break;
			case LIST:
				EnterOuterAlt(_localctx, 4);
				{
				State = 396;
				Match(LIST);
				State = 397;
				Match(LPAREN);
				State = 398;
				type();
				State = 399;
				Match(RPAREN);
				}
				break;
			case DECIMAL:
				EnterOuterAlt(_localctx, 5);
				{
				State = 401;
				Match(DECIMAL);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	private static int[] _serializedATN = {
		4,1,52,405,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,2,7,
		7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,7,14,
		2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,7,21,
		2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,7,28,
		2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,7,35,
		2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,7,42,
		2,43,7,43,1,0,1,0,1,1,1,1,1,1,1,1,3,1,95,8,1,1,2,1,2,3,2,99,8,2,1,3,1,
		3,1,3,1,3,1,3,1,4,1,4,1,4,3,4,109,8,4,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,
		1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,3,5,131,8,5,1,6,1,6,1,
		6,1,7,1,7,1,7,1,7,1,7,3,7,141,8,7,1,8,1,8,1,8,1,9,1,9,1,9,1,9,1,9,3,9,
		151,8,9,1,10,1,10,1,10,1,11,1,11,1,11,1,11,1,11,1,11,1,11,1,11,1,11,3,
		11,165,8,11,1,12,1,12,1,12,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,
		1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,3,13,187,8,13,1,14,1,14,1,14,1,
		15,1,15,1,15,1,15,1,15,1,15,1,15,1,15,1,15,3,15,201,8,15,1,16,1,16,1,16,
		1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,17,3,17,215,8,17,1,18,1,18,1,
		18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,3,18,228,8,18,1,19,1,19,1,19,
		1,19,1,20,1,20,1,21,1,21,3,21,238,8,21,1,22,1,22,1,22,1,22,1,22,1,22,1,
		22,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,3,23,257,8,23,1,24,
		1,24,1,24,1,25,1,25,1,25,1,26,1,26,1,26,3,26,268,8,26,1,27,1,27,1,27,1,
		27,1,27,1,27,1,28,1,28,1,28,1,28,1,28,1,28,1,29,1,29,1,29,1,29,1,29,1,
		29,1,29,1,29,1,29,1,30,1,30,3,30,293,8,30,1,31,1,31,1,31,1,31,1,31,1,31,
		1,31,1,31,1,31,1,31,1,31,1,31,1,31,1,31,3,31,309,8,31,1,32,1,32,1,32,1,
		32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,3,32,325,8,32,1,33,
		1,33,1,33,1,33,1,33,1,33,1,33,1,33,1,33,1,33,1,33,1,33,1,33,1,33,1,33,
		1,33,1,33,1,33,1,33,3,33,346,8,33,1,34,1,34,1,34,1,34,1,34,1,34,1,34,1,
		34,1,35,1,35,1,35,1,36,1,36,3,36,361,8,36,1,37,1,37,1,37,1,37,3,37,367,
		8,37,1,38,1,38,1,38,1,38,1,38,3,38,374,8,38,1,39,1,39,1,39,1,40,1,40,1,
		40,1,40,3,40,383,8,40,1,41,1,41,1,41,1,41,1,41,3,41,390,8,41,1,42,1,42,
		1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,3,43,403,8,43,1,43,0,0,44,
		0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,
		50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,0,1,1,0,17,18,
		407,0,88,1,0,0,0,2,94,1,0,0,0,4,98,1,0,0,0,6,100,1,0,0,0,8,108,1,0,0,0,
		10,130,1,0,0,0,12,132,1,0,0,0,14,140,1,0,0,0,16,142,1,0,0,0,18,150,1,0,
		0,0,20,152,1,0,0,0,22,164,1,0,0,0,24,166,1,0,0,0,26,186,1,0,0,0,28,188,
		1,0,0,0,30,200,1,0,0,0,32,202,1,0,0,0,34,214,1,0,0,0,36,227,1,0,0,0,38,
		229,1,0,0,0,40,233,1,0,0,0,42,237,1,0,0,0,44,239,1,0,0,0,46,256,1,0,0,
		0,48,258,1,0,0,0,50,261,1,0,0,0,52,267,1,0,0,0,54,269,1,0,0,0,56,275,1,
		0,0,0,58,281,1,0,0,0,60,292,1,0,0,0,62,308,1,0,0,0,64,324,1,0,0,0,66,345,
		1,0,0,0,68,347,1,0,0,0,70,355,1,0,0,0,72,360,1,0,0,0,74,366,1,0,0,0,76,
		373,1,0,0,0,78,375,1,0,0,0,80,382,1,0,0,0,82,389,1,0,0,0,84,391,1,0,0,
		0,86,402,1,0,0,0,88,89,3,2,1,0,89,1,1,0,0,0,90,91,3,4,2,0,91,92,3,2,1,
		0,92,95,1,0,0,0,93,95,1,0,0,0,94,90,1,0,0,0,94,93,1,0,0,0,95,3,1,0,0,0,
		96,99,3,10,5,0,97,99,3,6,3,0,98,96,1,0,0,0,98,97,1,0,0,0,99,5,1,0,0,0,
		100,101,3,86,43,0,101,102,5,51,0,0,102,103,3,8,4,0,103,104,5,11,0,0,104,
		7,1,0,0,0,105,106,5,9,0,0,106,109,3,12,6,0,107,109,1,0,0,0,108,105,1,0,
		0,0,108,107,1,0,0,0,109,9,1,0,0,0,110,111,5,51,0,0,111,112,5,9,0,0,112,
		113,3,12,6,0,113,114,5,11,0,0,114,131,1,0,0,0,115,131,3,42,21,0,116,117,
		3,60,30,0,117,118,5,11,0,0,118,131,1,0,0,0,119,131,3,68,34,0,120,121,3,
		66,33,0,121,122,5,11,0,0,122,131,1,0,0,0,123,124,3,40,20,0,124,125,5,11,
		0,0,125,131,1,0,0,0,126,127,5,38,0,0,127,128,3,86,43,0,128,129,5,11,0,
		0,129,131,1,0,0,0,130,110,1,0,0,0,130,115,1,0,0,0,130,116,1,0,0,0,130,
		119,1,0,0,0,130,120,1,0,0,0,130,123,1,0,0,0,130,126,1,0,0,0,131,11,1,0,
		0,0,132,133,3,16,8,0,133,134,3,14,7,0,134,13,1,0,0,0,135,136,5,1,0,0,136,
		137,3,16,8,0,137,138,3,14,7,0,138,141,1,0,0,0,139,141,1,0,0,0,140,135,
		1,0,0,0,140,139,1,0,0,0,141,15,1,0,0,0,142,143,3,20,10,0,143,144,3,18,
		9,0,144,17,1,0,0,0,145,146,5,2,0,0,146,147,3,20,10,0,147,148,3,18,9,0,
		148,151,1,0,0,0,149,151,1,0,0,0,150,145,1,0,0,0,150,149,1,0,0,0,151,19,
		1,0,0,0,152,153,3,24,12,0,153,154,3,22,11,0,154,21,1,0,0,0,155,156,5,3,
		0,0,156,157,3,24,12,0,157,158,3,22,11,0,158,165,1,0,0,0,159,160,5,4,0,
		0,160,161,3,24,12,0,161,162,3,22,11,0,162,165,1,0,0,0,163,165,1,0,0,0,
		164,155,1,0,0,0,164,159,1,0,0,0,164,163,1,0,0,0,165,23,1,0,0,0,166,167,
		3,28,14,0,167,168,3,26,13,0,168,25,1,0,0,0,169,170,5,5,0,0,170,171,3,28,
		14,0,171,172,3,26,13,0,172,187,1,0,0,0,173,174,5,6,0,0,174,175,3,28,14,
		0,175,176,3,26,13,0,176,187,1,0,0,0,177,178,5,7,0,0,178,179,3,28,14,0,
		179,180,3,26,13,0,180,187,1,0,0,0,181,182,5,8,0,0,182,183,3,28,14,0,183,
		184,3,26,13,0,184,187,1,0,0,0,185,187,1,0,0,0,186,169,1,0,0,0,186,173,
		1,0,0,0,186,177,1,0,0,0,186,181,1,0,0,0,186,185,1,0,0,0,187,27,1,0,0,0,
		188,189,3,32,16,0,189,190,3,30,15,0,190,29,1,0,0,0,191,192,5,19,0,0,192,
		193,3,32,16,0,193,194,3,30,15,0,194,201,1,0,0,0,195,196,5,20,0,0,196,197,
		3,32,16,0,197,198,3,30,15,0,198,201,1,0,0,0,199,201,1,0,0,0,200,191,1,
		0,0,0,200,195,1,0,0,0,200,199,1,0,0,0,201,31,1,0,0,0,202,203,3,36,18,0,
		203,204,3,34,17,0,204,33,1,0,0,0,205,206,5,21,0,0,206,207,3,36,18,0,207,
		208,3,34,17,0,208,215,1,0,0,0,209,210,5,22,0,0,210,211,3,36,18,0,211,212,
		3,34,17,0,212,215,1,0,0,0,213,215,1,0,0,0,214,205,1,0,0,0,214,209,1,0,
		0,0,214,213,1,0,0,0,215,35,1,0,0,0,216,217,5,13,0,0,217,218,3,12,6,0,218,
		219,5,14,0,0,219,228,1,0,0,0,220,228,3,66,33,0,221,228,3,64,32,0,222,228,
		5,50,0,0,223,228,5,49,0,0,224,228,5,48,0,0,225,228,5,51,0,0,226,228,3,
		84,42,0,227,216,1,0,0,0,227,220,1,0,0,0,227,221,1,0,0,0,227,222,1,0,0,
		0,227,223,1,0,0,0,227,224,1,0,0,0,227,225,1,0,0,0,227,226,1,0,0,0,228,
		37,1,0,0,0,229,230,5,15,0,0,230,231,3,2,1,0,231,232,5,16,0,0,232,39,1,
		0,0,0,233,234,5,47,0,0,234,41,1,0,0,0,235,238,3,44,22,0,236,238,3,50,25,
		0,237,235,1,0,0,0,237,236,1,0,0,0,238,43,1,0,0,0,239,240,5,30,0,0,240,
		241,5,13,0,0,241,242,3,12,6,0,242,243,5,14,0,0,243,244,3,38,19,0,244,245,
		3,46,23,0,245,45,1,0,0,0,246,247,5,31,0,0,247,248,5,30,0,0,248,249,5,13,
		0,0,249,250,3,12,6,0,250,251,5,14,0,0,251,252,3,38,19,0,252,253,3,46,23,
		0,253,257,1,0,0,0,254,257,3,48,24,0,255,257,1,0,0,0,256,246,1,0,0,0,256,
		254,1,0,0,0,256,255,1,0,0,0,257,47,1,0,0,0,258,259,5,31,0,0,259,260,3,
		38,19,0,260,49,1,0,0,0,261,262,5,32,0,0,262,263,3,52,26,0,263,51,1,0,0,
		0,264,268,3,54,27,0,265,268,3,56,28,0,266,268,3,58,29,0,267,264,1,0,0,
		0,267,265,1,0,0,0,267,266,1,0,0,0,268,53,1,0,0,0,269,270,5,13,0,0,270,
		271,3,12,6,0,271,272,5,14,0,0,272,273,5,33,0,0,273,274,3,38,19,0,274,55,
		1,0,0,0,275,276,5,34,0,0,276,277,5,13,0,0,277,278,3,12,6,0,278,279,5,14,
		0,0,279,280,3,38,19,0,280,57,1,0,0,0,281,282,5,35,0,0,282,283,5,13,0,0,
		283,284,3,86,43,0,284,285,5,51,0,0,285,286,5,36,0,0,286,287,5,51,0,0,287,
		288,5,14,0,0,288,289,3,38,19,0,289,59,1,0,0,0,290,293,3,62,31,0,291,293,
		3,64,32,0,292,290,1,0,0,0,292,291,1,0,0,0,293,61,1,0,0,0,294,295,5,51,
		0,0,295,296,5,12,0,0,296,297,5,43,0,0,297,298,5,13,0,0,298,299,3,80,40,
		0,299,300,5,14,0,0,300,309,1,0,0,0,301,302,5,51,0,0,302,303,5,12,0,0,303,
		304,5,45,0,0,304,305,5,13,0,0,305,306,3,80,40,0,306,307,5,14,0,0,307,309,
		1,0,0,0,308,294,1,0,0,0,308,301,1,0,0,0,309,63,1,0,0,0,310,311,5,51,0,
		0,311,312,5,12,0,0,312,313,5,44,0,0,313,314,5,13,0,0,314,315,3,80,40,0,
		315,316,5,14,0,0,316,325,1,0,0,0,317,318,5,51,0,0,318,319,5,12,0,0,319,
		320,5,46,0,0,320,321,5,13,0,0,321,322,3,80,40,0,322,323,5,14,0,0,323,325,
		1,0,0,0,324,310,1,0,0,0,324,317,1,0,0,0,325,65,1,0,0,0,326,327,5,39,0,
		0,327,328,5,51,0,0,328,329,5,13,0,0,329,330,3,80,40,0,330,331,5,14,0,0,
		331,346,1,0,0,0,332,333,5,39,0,0,333,334,5,41,0,0,334,335,5,13,0,0,335,
		336,3,80,40,0,336,337,5,14,0,0,337,346,1,0,0,0,338,339,5,39,0,0,339,340,
		3,86,43,0,340,341,5,42,0,0,341,342,5,13,0,0,342,343,3,80,40,0,343,344,
		5,14,0,0,344,346,1,0,0,0,345,326,1,0,0,0,345,332,1,0,0,0,345,338,1,0,0,
		0,346,67,1,0,0,0,347,348,5,37,0,0,348,349,5,51,0,0,349,350,5,13,0,0,350,
		351,3,74,37,0,351,352,5,14,0,0,352,353,3,70,35,0,353,354,3,38,19,0,354,
		69,1,0,0,0,355,356,5,38,0,0,356,357,3,72,36,0,357,71,1,0,0,0,358,361,3,
		86,43,0,359,361,5,27,0,0,360,358,1,0,0,0,360,359,1,0,0,0,361,73,1,0,0,
		0,362,363,3,78,39,0,363,364,3,76,38,0,364,367,1,0,0,0,365,367,1,0,0,0,
		366,362,1,0,0,0,366,365,1,0,0,0,367,75,1,0,0,0,368,369,5,10,0,0,369,370,
		3,78,39,0,370,371,3,76,38,0,371,374,1,0,0,0,372,374,1,0,0,0,373,368,1,
		0,0,0,373,372,1,0,0,0,374,77,1,0,0,0,375,376,3,86,43,0,376,377,5,51,0,
		0,377,79,1,0,0,0,378,379,3,12,6,0,379,380,3,82,41,0,380,383,1,0,0,0,381,
		383,1,0,0,0,382,378,1,0,0,0,382,381,1,0,0,0,383,81,1,0,0,0,384,385,5,10,
		0,0,385,386,3,12,6,0,386,387,3,82,41,0,387,390,1,0,0,0,388,390,1,0,0,0,
		389,384,1,0,0,0,389,388,1,0,0,0,390,83,1,0,0,0,391,392,7,0,0,0,392,85,
		1,0,0,0,393,403,5,23,0,0,394,403,5,24,0,0,395,403,5,25,0,0,396,397,5,28,
		0,0,397,398,5,13,0,0,398,399,3,86,43,0,399,400,5,14,0,0,400,403,1,0,0,
		0,401,403,5,26,0,0,402,393,1,0,0,0,402,394,1,0,0,0,402,395,1,0,0,0,402,
		396,1,0,0,0,402,401,1,0,0,0,403,87,1,0,0,0,24,94,98,108,130,140,150,164,
		186,200,214,227,237,256,267,292,308,324,345,360,366,373,382,389,402
	};

	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN);


}
